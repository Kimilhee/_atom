'use strict';
var _ = require('lodash'),
    async = require('async'),
    util = require('util');

var logger = require('log4js').getLogger('Agent'),
    applib = require('../../lib'),
    request = require('./request.js'),
    utils = require('../../../common/utils');

var GatewayAgent = require('../agent');

/**
 * Initialize LoRa Agent(Plugin)
 */
logger.info('[loriot_lora] Setting up loriot_lora agent');

function Agent() {
  logger.info('[loriot_lora/constructor] initialization');

  this.id = 'loriot_lora';

  this.Gateways = {};
  this.Sensors = {};
}

util.inherits(Agent, GatewayAgent);

function getGatewayAndParser(gatewayId, cb) {
  async.waterfall([
    function getGateway(done) {
      applib.retrieveItem(gatewayId, 'gateway', null, done);
    },
    function checkValidDelegateInfo(gateway, done) {
      if (!gateway) {
        return done(new Error('No gateway found with gatewayId:' + gatewayId));
      }

      if (!gateway.delegateInfo || !gateway.delegateInfo.parser) {
        logger.warn('No gateway.delegateInfo', gateway.delegateInfo);
        return done(new Error('No delegateInfo or parser defined!'));
      }
      
      done(null, gateway);
    },
    function getParser(gateway, done) {
      var delegateInfo = gateway.delegateInfo;
      var parser = GatewayAgent.getParser(delegateInfo.parser.vendor, delegateInfo.parser.model);
      
      if (!parser) {
        logger.warn('[loriot_lora/getGatewayAndParser] delegateInfo.parser:', delegateInfo.parser);
        return done(new Error('Cannot get valid parser!'));
      }
      
      done(null, gateway, parser);
    },
  ], function(err, gateway, parser) {
    if (err) {
      return logger.warn(err);
    }
    
    cb(gateway, parser);
  });
}


/**
 * Parse push message and send the parsed message to the message broker
 * @param Object data Push message
 */
Agent.prototype.pushNotification = function (data) {
  logger.info('[loriot_lora/pushNotification]', data);

  var self = this,
      realId = data.EUI,
      payload = data.data;
      
  realId = utils.getSafeGatewayId(realId);

  if (!realId) {
    return logger.warn('[loriot_lora/pushNotification] DevEUI is missing', data);
  }
  
  getGatewayAndParser(realId, function(gateway, parser) {
    var parsedResults = parser.parse(payload);    

    if (!parsedResults) {
      return logger.warn('[loriot_lora/pushNotification] invalid payload:', payload, gateway.parser.validator);
    }
    
    logger.info('[loriot_lora/pushNotification] Valid payload :', payload);
    
    async.each(gateway.sensors, function(sensorId, next) {
      applib.retrieveItem(sensorId, 'sensor', null, function (err, sensor) {
        if (err) {
          return next(err);
        }
        
        var sensorVal = _.find(parsedResults, { type: sensor.type, sequence: +sensor.sequence || 1 });
        
        if (!sensorVal || _.isUndefined(sensorVal.value)) {
          return next();
        }
        
        self.pushSensorStatus(gateway, sensor);
        self.pushSensorData(gateway, sensor, sensorVal, data.ts);
        next();
      });
    }, function() {
      logger.info('[loriot_lora/pushNotification] end!');
    });
  });
};

/**
 * Parse execInstance message and send the parsed message to the message broker
 * @param Object result OneM2M exs body
 */
Agent.prototype.callbackCommand = function (result) {
  logger.info('[loriot_lora/callbackCommand] result', result);
};

/**
 * Handler for the push message from the loriot_lora platform (contentInstance, execInstance)
 * @param String branchId Branch ID to distinguish specific case such as PusanSmartCity, SKTIoT, etc.
 * @param String data Message body
 */
Agent.prototype.handleNotification = function (branchId, data) {
  var self = this;

  logger.debug('[loriot_lora/handleNotification] agent branch ID', branchId, data);
  
  var result = data.content;

  if (!result) {
    logger.warn('[loriot_lora/handleNotification] payload data');
    return;
  }

  switch (result.cmd) {
  case 'rx':     // from LoRa rx message
    self.pushNotification(result);
    break;
  default:
    logger.warn('[loriot_lora/handleNotification] Not supported result', result);
  }
};

/**
 * Map sensor/actuator data between loriot_lora Platform and Service Platform and Subscribe to the container
 * @param Object item Sensor information from the Service Platform
 * @param Object opts Options to match data (force: furceful match regardless of the previous match)
 * @param Function cb Callback function
 */
Agent.prototype.matchSensor = function (item, opts, cb) {
  logger.info('[loriot_lora/matchSensor] item:', item, ' opts=', opts);
  // targetId is Service platform(TP) Sensor ID
  // realId is loriot_lora Sensor ID(Generated by Service platform)

  var self = this;
  var realId = item.delegateInfo.realId;
  var matchingItem;

  self.Sensors[realId] = self.Sensors[realId] || {};

  matchingItem = {
    id: realId,
    targetId: item.id,
    ownerId: item.owner,
    category: item.category,
    type: item.type,
    sequence: item.sequence,
    branchId: item.delegateInfo.branchId
  };

  _.merge(self.Sensors[realId], matchingItem);

  logger.info('[loriot_lora/matchSensor] Sensors', _.size(self.Sensors));

  return cb && cb();
};

/**
 * Clear the mapping data of sensor/actuator and Unsubscribe to the container of the sensor/actuator
 * @param String sensorId Sensor ID of the Service Platform
 * @param Function cb Callback function
 */
Agent.prototype.clearSensor = function (sensorId, cb) {
  // sensorId is Service platform(TP) Sensor ID(UUID)
  // ownerId is Service platform(TP) Gateway ID(UUID)
  var self = this;
  var sensor = self.Sensors[sensorId];

  logger.info('[loriot_lora/clearSensor] sensorId', sensorId);

  if (!sensor) {
    logger.warn('[loriot_lora/clearSensor] Sensor is not found', self.Sensors);
    return cb && cb();
  }

  self.Sensors[sensorId] = null;
  delete self.Sensors[sensorId];

  return cb && cb();
};

/**
 * Map gateway data between loriot_lora Platform and Service Platform and Subscribe to the container
 * @param Object item Gateway information from the Service Platform
 * @param Function cb Callback function
 */
Agent.prototype.matchGateway = function (item, cb) {
  // targetId is Service platform(TP) Gateway ID(EUI-64)
  // realId is loriot_lora Gateway ID(DevEUI)

  if (!item || !item.delegateInfo) {
    return cb && cb(new Error('item delegateInfo is required'));
  }

  var self = this;
  var realId = utils.getSafeGatewayId(item.delegateInfo.realId);
  var matchingItem;

  logger.info('[loriot_lora/matchGateway] realId, targetId', realId, item && item.id);

  self.Gateways[realId] = self.Gateways[realId] || {};

  matchingItem = {
    id: realId,
    targetId: item.id,
    reportInterval: item.reportInterval,
    branchId: item.delegateInfo.branchId,
    parser: item.delegateInfo.parser,
    refId: item.delegateInfo.refId
  };

  _.merge(self.Gateways[realId], matchingItem);

  logger.info('[loriot_lora/matchGateway] Matched Gateway', self.Gateways[realId]);    

  return cb && cb(); 
};

// jshint -W098 
/**
 * Clear the mapping data of gateway and Unsubscribe to the container of the gateway
 * @param String gatewayId Gateway ID of the Service Platform
 * @param Function cb Callback function
 */
Agent.prototype.clearGateway = function (gatewayId, cb) {
  // gatewayId is Service platform(TP) Gateway ID(UUID)
  logger.info('[loriot_lora/clearGateway] gatewayId', gatewayId);
};

Agent.prototype.retrieveGateway = function (gatewayId, opts, cb, queued) {
  logger.info('[loriot_lora/retrieveGateway] gatewayId, opts', gatewayId, opts);
};

Agent.prototype.createGateway = function (item, opts, cb, queued) {
  logger.info('[loriot_lora/createGateway] item, opts', item, opts);    
};

Agent.prototype.updateGateway = function (item, opts, cb, queued) {
  logger.info('[loriot_lora/updateGateway] item, opts', item, opts);
};

Agent.prototype.deleteGateway = function (gatewayId, opts, cb) {
  logger.info('[loriot_lora/deleteGateway] gatewayId, opts', gatewayId, opts);
};

Agent.prototype.setProperty = function (gatewayId, messageId, params) {
  if (params && params.reportInterval) {
    /*
    {
      "cmd"       : "tx",
      "EUI"       : "4786E6ED0053004B",         
      "port"      : 8,
      "confirmed" : true,
      "data"      : "1E00"
    }
    */
    
    // request.post({
    //   cmd: 'tx',
    //   EUI: gatewayId.toUpperCase(),
    // });
  }
  
  logger.info('[agent/setProperty] Not Supporting - gatewayId, messageId, params',
      gatewayId, messageId, params);
};


module.exports = new Agent();
